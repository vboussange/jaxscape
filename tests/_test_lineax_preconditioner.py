# preconditioner generated by ChatGPT, does not work
# implementation in jax-cfd could be interesting, see https://github.com/google/jax-cfd

import jax
import jax.numpy as jnp
from jax import jit
from functools import partial

# Problem parameters
N = 64  # Grid size (must be a power of 2)
h = 1.0 / (N + 1)  # Grid spacing
D_x = 1.0  # Diffusion coefficient in x-direction
D_y = 0.1  # Diffusion coefficient in y-direction

# Define the anisotropic Laplacian operator with zero Dirichlet boundary conditions
def apply_A(x):
    x = x.reshape((N, N))
    x_padded = jnp.pad(x, pad_width=1, mode='constant')
    laplace_x = (x_padded[2:, 1:-1] - 2 * x + x_padded[:-2, 1:-1]) / h**2
    laplace_y = (x_padded[1:-1, 2:] - 2 * x + x_padded[1:-1, :-2]) / h**2
    Ax = D_x * laplace_x + D_y * laplace_y
    return Ax.reshape(-1)

# Jacobi smoother
def jacobi_smoother(x, b, omega=2/3, iterations=5):
    diag = -2 * (D_x + D_y) / h**2
    inv_diag = -1 / diag  # Diagonal entries are negative
    x = x.reshape((N, N))
    b = b.reshape((N, N))

    def body_fun(i, x):
        Ax = apply_A(x.reshape(-1)).reshape((N, N))
        x_new = x + omega * inv_diag * (b - Ax)
        return x_new

    x = jax.lax.fori_loop(0, iterations, body_fun, x)
    return x.reshape(-1)

# Restriction operator using averaging
def restrict(x):
    x = x.reshape((N, N))
    x_coarse = 0.25 * (x[0:-1:2, 0:-1:2] + x[1::2, 0:-1:2] +
                       x[0:-1:2, 1::2] + x[1::2, 1::2])
    return x_coarse.reshape(-1)

# Prolongation operator using linear interpolation
def prolong(x_coarse):
    N_coarse = x_coarse.shape[0]  # Should be (N/2)^2
    N_coarse_side = int(jnp.sqrt(N_coarse))
    x_coarse = x_coarse.reshape((N_coarse_side, N_coarse_side))
    x_fine = jax.image.resize(x_coarse, (N, N), method='linear')
    return x_fine.reshape(-1)

# Multigrid V-cycle preconditioner
def multigrid_v_cycle(x, b):
    # Pre-smoothing
    x = jacobi_smoother(x, b, iterations=5)

    # Compute residual
    r = b - apply_A(x)

    # Restrict residual to coarse grid
    r_coarse = restrict(r)
    N_coarse = int(N / 2)

    # Initialize coarse grid solution
    e_coarse = jnp.zeros_like(r_coarse)

    # Coarse grid solver (Jacobi smoother as a placeholder)
    def coarse_grid_solver(e_coarse, r_coarse):
        diag_coarse = -2 * (D_x + D_y) / (2 * h)**2
        inv_diag_coarse = -1 / diag_coarse

        def body_fun(i, e_coarse):
            e_coarse = e_coarse.reshape((N_coarse, N_coarse))
            Ae_coarse = apply_A(e_coarse.reshape(-1)).reshape((N_coarse, N_coarse))
            e_coarse = e_coarse + (2/3) * inv_diag_coarse * (r_coarse.reshape((N_coarse, N_coarse)) - Ae_coarse)
            return e_coarse.reshape(-1)

        e_coarse = jax.lax.fori_loop(0, 5, body_fun, e_coarse)
        return e_coarse

    e_coarse = coarse_grid_solver(e_coarse, r_coarse)

    # Prolongate correction
    e_fine = prolong(e_coarse)

    # Correct fine grid solution
    x = x + e_fine

    # Post-smoothing
    x = jacobi_smoother(x, b, iterations=5)
    return x

# Preconditioner function
def preconditioner(b):
    x0 = jnp.zeros_like(b)
    x = multigrid_v_cycle(x0, b)
    return x

# Custom GMRES solver with preconditioning
def gmres_custom(A, b, M, tol=1e-6, maxiter=100):
    n = b.shape[0]
    x = jnp.zeros_like(b)
    r = b - A(x)
    z = M(r)
    beta = jnp.linalg.norm(z)
    Q = jnp.zeros((n, maxiter + 1))
    Q = Q.at[:, 0].set(z / beta)
    H = jnp.zeros((maxiter + 1, maxiter))
    for k in range(maxiter):
        y = A(Q[:, k])
        w = M(y)
        for j in range(k + 1):
            H = H.at[j, k].set(jnp.dot(Q[:, j], w))
            w = w - H[j, k] * Q[:, j]
        H = H.at[k + 1, k].set(jnp.linalg.norm(w))
        if H[k + 1, k] != 0 and k + 1 < maxiter:
            Q = Q.at[:, k + 1].set(w / H[k + 1, k])
        else:
            break
        # Solve least squares problem
        e1 = jnp.zeros(k + 2)
        e1 = e1.at[0].set(beta)
        y, residuals, rank, s = jnp.linalg.lstsq(H[:k + 2, :k + 1], e1, rcond=None)
        x = x + Q[:, :k + 1] @ y
        if jnp.linalg.norm(b - A(x)) < tol:
            break
    return x

# JIT compile the preconditioner and GMRES solver
apply_A_jit = jit(apply_A)
preconditioner_jit = jit(preconditioner)
gmres_solver_jit = jit(partial(gmres_custom, apply_A_jit, M=preconditioner_jit))

# Define the right-hand side
b = jnp.ones(N * N)

# Solve the system
x_solution = gmres_solver_jit(b)

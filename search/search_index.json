{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Getting started","text":"<p>JAXScape is a minimal JAX library for connectivity analysis at scales. It provide key utilities to build your own connectivity analysis workflow, including</p> <ul> <li>differentiable and GPU-accelerated graph distance metrics</li> <li>differentiable raster to graph and graph to raster mappings</li> <li>moving window utilities for implementing large-scale connectivity analysis pipelines</li> </ul> <p>JAXScape leverages JAX's capabilities to accelerate distance computations on CPUs/GPUs/TPUs, while ensuring differentiability of all implemented classes and methods for awesome sensitivity analysis and optimization.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>uv add jaxscape\n</code></pre> <p>For GPU compatibility, install JAX following the official JAX installation guide. JAXScape will automatically use the JAX backend you have configured.</p> <p>You may be required to install optional linear solvers for large-scale resistance distance computations (see the documentation page).</p>"},{"location":"#quick-start","title":"Quick start","text":"<pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nimport jax.numpy as jnp\nfrom jaxscape import GridGraph\nfrom jaxscape import LCPDistance, ResistanceDistance, RSPDistance\n\n# loading jax array representing permeability\npermeability = jnp.array(np.loadtxt(\"permeability.csv\", delimiter=\",\")) + 0.001\n\n# Create a grid graph where edge weights are the average permeability of the two nodes\ngrid = GridGraph(grid=permeability, fun=lambda x, y: (x + y) / 2)\n\n# We set the source to the top left pixel, and compute distances to all other pixels with three different distance metrics\nsource = grid.coord_to_index(jnp.array([0]), jnp.array([0]))\n\ndistances = {\n    \"LCP distance\": LCPDistance(),\n    \"Resistance distance\": ResistanceDistance(),\n    \"RSP distance\": RSPDistance(theta=0.01, cost=lambda x: -jnp.log(x)),\n}\n\nfig, axs = plt.subplots(1, 3, figsize=(10, 4))\nfor ax, (title, distance) in zip(axs, distances.items()):\n    # Compute distances from all nodes to the source\n    dist_to_node = distance(grid, source)\n\n    # Convert from node values to 2D array and mask low-permeability areas\n    dist_array = grid.node_values_to_array(dist_to_node.ravel())\n    dist_array = dist_array * (permeability &gt; 0.1)  # Mask barriers\n\n    # Plotting\n    im = ax.imshow(dist_array, cmap=\"magma\")\n    ax.axis(\"off\")\n    ax.set_title(title)\n    fig.colorbar(im, ax=ax, shrink=0.2)\n\nfig.suptitle(\"Distance to top left pixel\")\nplt.tight_layout()\nplt.show()\n</code></pre> <p>But what's really cool about jaxscape is that you can autodiff through thoses distances! Check out the documentation to learn about applications and more!</p>"},{"location":"#features-and-roadmap","title":"Features and roadmap \ud83d\ude80","text":"<p>See issues; most notably:</p> <ul> <li>[ ] Support for direct and iterative linear sparse solvers on GPU (cf spineax)</li> <li>[ ] Benchmark against <code>CircuitScape</code>, <code>ConScape.jl</code> and <code>radish</code>.</li> </ul>"},{"location":"#license","title":"License","text":"<p><code>jaxscape</code> is distributed under the terms of the MIT license.</p>"},{"location":"#related-packages","title":"Related packages","text":"<ul> <li>gdistance</li> <li>ConScape</li> <li>Circuitscape</li> <li>graphhab</li> <li>conefor</li> <li>resistanceGA</li> <li>landscapemetrics</li> <li>radish</li> </ul>"},{"location":"#citation","title":"Citation","text":"<p>If you use JAXScape in your research, please cite:</p> <pre><code>@software{jaxscape2024,\n  author = {Boussange, Victor},\n  title = {JAXScape: A minimal JAX library for connectivity modelling at scale},\n  year = {2024},\n  doi = {10.5281/zenodo.15267703},\n  url = {https://github.com/vboussange/jaxscape}\n}\n</code></pre>"},{"location":"api/connectivity_analysis/","title":"Connectivity analysis","text":"<p>JAXScape provides connectivity and sensitivity analysis utilities, based on the opiniated definition of ecological connectivity as the sum of ecological proximity, which can process large rasters efficiently using windowed operations. Users who want to obtain a finer control over the definition of ecological connectivity can use the lower-level window operations directly (see Window operations).</p>"},{"location":"api/connectivity_analysis/#jaxscape.connectivity_analysis.ConnectivityAnalysis","title":"<code>jaxscape.connectivity_analysis.ConnectivityAnalysis</code>","text":"<p>Compute landscape connectivity metrics for large rasters.</p> <p>Quantifies connectivity by suming pairwise proximity in the graph. When quality-weighted, retrieves the quantity:</p> \\[C = \\sum_i \\sum_{j \\neq i} q_i \\, K_{ij} \\, q_j\\] <p>where \\(q_i\\) is habitat quality at pixel \\(i\\) and \\(K_{ij} = f(d_{ij})\\) is the proximity between pixels based on distance \\(d_{ij}\\).</p> <p>Uses windowed processing for memory efficiency. See <code>WindowedAnalysis</code> for windowing parameters and strategy.</p> <p>Example</p> <pre><code>from jaxscape import ConnectivityAnalysis, LCPDistance import\njax.numpy as jnp\n\n# Setup landscape D = 20  # Dispersal range distance = LCPDistance()\nproximity = lambda dist: jnp.exp(-dist / D)\n\n# Pad rasters to avoid edge effects quality_padded = jnp.pad(quality, D,\nconstant_values=0) permeability_padded = jnp.pad(permeability, D,\nconstant_values=0)\n\n# Initialize analysis conn = ConnectivityAnalysis(\n    quality_raster=quality_padded,\n    permeability_raster=permeability_padded, distance=distance,\n    proximity=proximity, dependency_range=D, coarsening_factor=0.2,\n    batch_size=50\n)\n\n# Compute connectivity connectivity_index = conn.run(q_weighted=True)\n</code></pre> <p>Contiguity</p> <p>The underlying graph is constructed using rook contiguity (4-neighbor connectivity), and edge weights are computed as the average permeability between adjacent pixels.</p>"},{"location":"api/connectivity_analysis/#jaxscape.connectivity_analysis.ConnectivityAnalysis.run","title":"<code>run(q_weighted: bool = True) -&gt; Array</code>","text":"<p>Compute the connectivity metric across the landscape.</p> <p>Arguments:</p> <ul> <li><code>q_weighted</code>: If <code>True</code>, compute quality-weighted connectivity (expected   habitat amount). If <code>False</code>, compute unweighted proximity sum.</li> </ul> <p>Returns:</p> <p>Scalar landscape connectivity value.</p>"},{"location":"api/connectivity_analysis/#jaxscape.connectivity_analysis.SensitivityAnalysis","title":"<code>jaxscape.connectivity_analysis.SensitivityAnalysis</code>","text":"<p>Compute connectivity sensitivity via automatic differentiation.</p> <p>Calculates gradients \\(\\partial C / \\partial q_i\\) or \\(\\partial C / \\partial p_i\\) showing how connectivity responds to changes in habitat quality or permeability at each pixel. Uses JAX's automatic differentiation for efficient gradient computation.</p> <p>Parameters and windowing strategy are identical to <code>ConnectivityAnalysis</code>.</p> <p>Example</p> <pre><code>from jaxscape import SensitivityAnalysis, ResistanceDistance\nimport jax.numpy as jnp\n\n# Setup (same as ConnectivityAnalysis)\nD = 20\ndistance = ResistanceDistance()\nproximity = lambda dist: jnp.exp(-dist / D)\n\nsens = SensitivityAnalysis(\n    quality_raster=quality_padded,\n    permeability_raster=permeability_padded,\n    distance=distance,\n    proximity=proximity,\n    dependency_range=D,\n    coarsening_factor=0.2,\n    batch_size=50\n)\n\n# Compute sensitivity gradients\nd_quality = sens.run(\"quality\", q_weighted=True)\nd_permeability = sens.run(\"permeability\", q_weighted=True)\n\n# Identify conservation priorities\nhigh_impact = d_quality &gt; jnp.percentile(d_quality, 90)\n</code></pre>"},{"location":"api/connectivity_analysis/#jaxscape.connectivity_analysis.SensitivityAnalysis.run","title":"<code>run(var: str = 'quality', q_weighted: bool = True) -&gt; Array</code>","text":"<p>Compute connectivity gradients with respect to a landscape parameter.</p> <p>Arguments:</p> <ul> <li><code>var</code>: Parameter to differentiate: <code>\"quality\"</code> or <code>\"permeability\"</code>.</li> <li><code>q_weighted</code>: If <code>True</code>, compute quality-weighted connectivity gradients.   If <code>False</code>, compute unweighted gradients.</li> </ul> <p>Returns:</p> <p>Gradient raster with the same shape as the input, showing sensitivity at each pixel.</p>"},{"location":"api/distances/","title":"Distance metrics","text":""},{"location":"api/distances/#jaxscape.distance.AbstractDistance","title":"<code>jaxscape.distance.AbstractDistance</code>","text":"<p>Abstract base class for distance computations on graphs.</p> <p>Provides a unified interface for computing distances with automatic handling of coordinate-based (for <code>GridGraph</code>) or index-based node specification.</p> <p>Arguments:</p> <ul> <li><code>graph</code>: Graph on which to compute distances.</li> <li><code>sources</code>: Source nodes as vertex indices (1D array) or coordinates (Nx2 array for <code>GridGraph</code>).</li> <li><code>targets</code>: Target nodes as vertex indices (1D array) or coordinates (Nx2 array for <code>GridGraph</code>).</li> <li><code>nodes</code>: Nodes for pairwise distances as vertex indices (1D) or coordinates (Nx2).</li> </ul> <p>Specify either: <code>nodes</code> alone, <code>sources</code> and/or <code>targets</code>, or neither (for all-pairs).</p> <p>Returns:</p> <p>Distance array with shape depending on the inputs.</p> <p>Example</p> <pre><code>from jaxscape import LCPDistance, GridGraph\nimport jax.numpy as jnp\n\ndistance = LCPDistance()\ngrid = GridGraph(permeability, fun=lambda x, y: (x + y) / 2)\n\n# All-pairs distance\nD = distance(grid)  # Shape: (n_nodes, n_nodes)\n\n# Using vertex indices\nD = distance(grid, sources=jnp.array([0, 1]), targets=jnp.array([10, 20]))  # Shape: (2, 2)\n\n# Using coordinates (for GridGraph)\nD = distance(grid, sources=jnp.array([[0, 0], [1, 1]]), targets=jnp.array([[10, 10]]))  # Shape: (2, 1)\n\n# Pairwise among subset\nD = distance(grid, nodes=jnp.array([0, 5, 10]))  # Shape: (3, 3)\n</code></pre>"},{"location":"api/distances/#jaxscape.euclidean_distance.EuclideanDistance","title":"<code>jaxscape.euclidean_distance.EuclideanDistance</code>","text":"<p>Straight-line distance in grid coordinates. Only works with <code>GridGraph</code>.</p> <p>Example</p> <pre><code>from jaxscape import EuclideanDistance\n\ndistance = EuclideanDistance()\ndist = distance(grid, sources=source_coords, targets=target_coords)\n</code></pre>"},{"location":"api/distances/#jaxscape.euclidean_distance.EuclideanDistance.__call__","title":"<code>__call__(graph: AbstractGraph, sources: typing.Optional[jax.Array] = None, targets: typing.Optional[jax.Array] = None, nodes: typing.Optional[jax.Array] = None) -&gt; Array</code>","text":""},{"location":"api/distances/#jaxscape.lcp_distance.LCPDistance","title":"<code>jaxscape.lcp_distance.LCPDistance</code>","text":"<p>Compute least-cost path distances using shortest path algorithms.</p> <p>Currently supports two algorithms:</p> <ul> <li>Bellman-Ford (default): Efficient for sparse graphs and few sources.   Complexity O(V \u00d7 E \u00d7 S) where S is the number of sources.</li> <li>Floyd-Warshall: Efficient for all-pairs on small dense graphs.   Complexity O(V\u00b3), converts to dense matrix.</li> </ul> <p>Parameters:</p> <ul> <li><code>algorithm</code>: Algorithm choice: <code>\"bellman-ford\"</code> (default) or <code>\"floyd-warshall\"</code>.</li> </ul> <p>Example</p> <pre><code>from jaxscape import LCPDistance, GridGraph\nimport jax.numpy as jnp\n\ngrid = GridGraph(permeability, fun=lambda x, y: (x + y) / 2)\n\n# Default: Bellman-Ford (efficient for sparse graphs)\ndistance = LCPDistance()\nD = distance(grid, sources=jnp.array([0, 1]), targets=jnp.array([10, 20]))\n\n# Floyd-Warshall (efficient for small all-pairs)\ndistance_fw = LCPDistance(algorithm=\"floyd-warshall\")\nD_all = distance_fw(grid)  # All-pairs distance\n</code></pre>"},{"location":"api/distances/#jaxscape.lcp_distance.LCPDistance.__call__","title":"<code>__call__(graph: AbstractGraph, sources: typing.Optional[jax.Array] = None, targets: typing.Optional[jax.Array] = None, nodes: typing.Optional[jax.Array] = None) -&gt; Array</code>","text":""},{"location":"api/distances/#jaxscape.resistance_distance.ResistanceDistance","title":"<code>jaxscape.resistance_distance.ResistanceDistance</code>","text":"<p>Compute the resistance distances.</p> <p>Attributes:</p> <ul> <li><code>solver</code>: Optional <code>lineax.AbstractLinearSolver</code>. Must be compatible with BCOO matrices. We currently support <code>jaxscape.solvers.CholmodSolver</code> and <code>jaxscape.solvers.PyAMGSolver</code>. If None, uses pseudo-inverse method, which is very memory intensive for large graphs (densifies the Laplacian matrix).</li> </ul> <p>Example</p> <pre><code>from jaxscape import ResistanceDistance\nfrom jaxscape.solvers import PyAMGSolver\n\n# Default: pseudo-inverse (small graphs)\ndistance = ResistanceDistance()\n\n# With solver (large graphs)\ndistance = ResistanceDistance(solver=PyAMGSolver())\n\ndist = distance(grid)\n</code></pre> <p>Warning</p> <p>The graph must be undirected for resistance distance to be well-defined.</p>"},{"location":"api/distances/#jaxscape.resistance_distance.ResistanceDistance.__call__","title":"<code>__call__(graph: AbstractGraph, sources: typing.Optional[jax.Array] = None, targets: typing.Optional[jax.Array] = None, nodes: typing.Optional[jax.Array] = None) -&gt; Array</code>","text":""},{"location":"api/distances/#jaxscape.rsp_distance.RSPDistance","title":"<code>jaxscape.rsp_distance.RSPDistance</code>","text":"<p>Randomized shortest path distance. Requires the temperature parameter <code>theta</code> and <code>cost</code>, which can be either a <code>jax.experimental.sparse.BCOO</code> matrix or a function that will be used to map all non zero element of the adjacency matrix to create the cost matrix. <code>cost</code> defaults to the well adapted movement cost function <code>lambda x: -jnp.log(x))</code>.</p> <p>Warning</p> <p>This distance metric is experimental and may change in future releases.</p> <p>Example</p> <pre><code>from jaxscape import RSPDistance\n\ndistance = RSPDistance(theta=0.01, cost=lambda x: -jnp.log(x))\ndist = distance(grid)\n</code></pre>"},{"location":"api/distances/#jaxscape.rsp_distance.RSPDistance.__call__","title":"<code>__call__(graph: AbstractGraph, sources: typing.Optional[jax.Array] = None, targets: typing.Optional[jax.Array] = None, nodes: typing.Optional[jax.Array] = None) -&gt; Array</code>","text":""},{"location":"api/graphs/","title":"Graphs","text":""},{"location":"api/graphs/#jaxscape.graph.AbstractGraph","title":"<code>jaxscape.graph.AbstractGraph</code>","text":"<p>Abstract base class for graphs.</p>"},{"location":"api/graphs/#jaxscape.graph.Graph","title":"<code>jaxscape.graph.Graph</code>","text":"<p>A simple graph defined by an adjacency matrix.</p> <p>Arguments:</p> <ul> <li><code>adjacency_matrix</code>: A <code>jax.experimental.sparse.BCOO</code> adjacency matrix.</li> </ul>"},{"location":"api/graphs/#jaxscape.graph.Graph.get_adjacency_matrix","title":"<code>get_adjacency_matrix() -&gt; BCOO</code>","text":""},{"location":"api/graphs/#jaxscape.graph.GridGraph","title":"<code>jaxscape.graph.GridGraph</code>","text":"<p>Grid graph where vertices are defined by a rectangular <code>grid</code>.</p> <p>Arguments:</p> <ul> <li><code>grid</code> is a 2D array of shape <code>(height, width)</code> used to define edge weights. When calculating distances, edge weights are assume to represent permeability (i.e., 1/resistance, higher values indicate easier movement).</li> <li><code>fun</code> is a function applied to the source and target node values to define the edge weight. It takes two arrays and returns an array of the same size. Defaults to assigning the target vertex weight (<code>fun = lambda x, y: y</code>).</li> <li><code>neighbors</code> defines the contiguity pattern, and can be either <code>ROOK_CONTIGUITY</code> or <code>QUEEN_CONTIGUITY</code>.</li> </ul>"},{"location":"api/graphs/#jaxscape.graph.GridGraph.coord_to_index","title":"<code>coord_to_index(i: Array, j: Array) -&gt; Array</code>","text":"<p>Convert (i, j) grid coordinates to the associated passive vertex index.</p>"},{"location":"api/graphs/#jaxscape.graph.GridGraph.index_to_coord","title":"<code>index_to_coord(v: Array) -&gt; Array</code>","text":"<p>Convert passive vertex index <code>v</code> to (i, j) grid coordinates.</p>"},{"location":"api/graphs/#jaxscape.graph.GridGraph.node_values_to_array","title":"<code>node_values_to_array(values: Array) -&gt; Array</code>","text":"<p>Reshapes the 1D array values of vertices to the underlying 2D grid.</p>"},{"location":"api/graphs/#jaxscape.graph.GridGraph.array_to_node_values","title":"<code>array_to_node_values(array: Array) -&gt; Array</code>","text":"<p>Reshapes the 1D array values of vertices to the underlying 2D grid.</p>"},{"location":"api/solvers/","title":"Linear solvers","text":"<p>Distance computations requiring a linear system solve can be accelerated using specialized solvers. The user can select any solver compatible with the Lineax library to perform these computations, and use additional custom JAXScape solvers wrapped into Lineax solvers. </p>"},{"location":"api/solvers/#using-lineax-solvers","title":"Using <code>lineax</code> solvers","text":"<p>You can use any Lineax solver with <code>ResistanceDistance</code>:</p> <pre><code>import lineax as lx\n\n# Conjugate Gradient\nsolver = lx.CG(rtol=1e-6, atol=1e-6)\ndistance = ResistanceDistance(solver=solver)\n</code></pre> <p>See the Lineax documentation for available solvers and their options.</p>"},{"location":"api/solvers/#jaxscape-solvers","title":"<code>JAXScape</code> solvers","text":""},{"location":"api/solvers/#jaxscape.solvers.pyamgsolver.PyAMGSolver","title":"<code>jaxscape.solvers.pyamgsolver.PyAMGSolver</code>","text":"<p>A linear solver that uses PyAMG to solve a sparse linear system.</p> <p>Example</p> <pre><code>from jaxscape.solvers import PyAMGSolver\n\nsolver = PyAMGSolver(rtol=1e-6, maxiter=100_000)\ndistance = ResistanceDistance(solver=solver)\ndist = distance(grid)\n\n# Custom AMG method\nimport pyamg\nsolver = PyAMGSolver(pyamg_method=pyamg.ruge_stuben_solver)\n</code></pre> <p>Warning</p> <p>PyAMG must be installed to use this solver.</p>"},{"location":"api/solvers/#jaxscape.solvers.cholmodsolver.CholmodSolver","title":"<code>jaxscape.solvers.cholmodsolver.CholmodSolver</code>","text":"<p>A linear solver that uses CHOLMOD (via cholespy) to solve a sparse linear system. Uses direct Cholesky factorization for symmetric positive definite matrices.</p> <p>Example</p> <pre><code>from jaxscape.solvers import CholmodSolver\n\nsolver = CholmodSolver()\ndistance = ResistanceDistance(solver=solver)\ndist = distance(grid)\n</code></pre> <p>Warning</p> <p><code>cholespy</code> must be installed to use this solver.</p>"},{"location":"api/solvers/#advanced-bcoolinearoperator","title":"Advanced: <code>BCOOLinearOperator</code>","text":"<p><code>JAXScape</code> provides a custom linear operator compatible with Lineax that leverages the BCOO sparse matrix format.</p>"},{"location":"api/solvers/#jaxscape.solvers.operator.BCOOLinearOperator","title":"<code>jaxscape.solvers.operator.BCOOLinearOperator</code>","text":"<p><code>lineax.MatrixLinearOperator</code> wrapper for <code>jax.experimental.sparse.BCOO</code> matrices.</p>"},{"location":"api/window_operations/","title":"Advanced: custom window operations","text":""},{"location":"api/window_operations/#jaxscape.utils.padding","title":"<code>jaxscape.utils.padding(raster: Array, buffer_size: int, window_size: int) -&gt; Array</code>","text":"<p>Pad raster to ensure dimensions are compatible with <code>WindowOperation</code>.</p> <p>Ensures <code>(raster.shape[i] - 2 * buffer_size) % window_size == 0</code>.</p> <p>Example</p> <pre><code>from jaxscape.utils import padding\n\nraster = jnp.ones((100, 100))\npadded = padding(raster, buffer_size=10, window_size=25)\n</code></pre>"},{"location":"api/window_operations/#jaxscape.window_operation.WindowOperation","title":"<code>jaxscape.window_operation.WindowOperation</code>","text":"<p>Manages window-based operations on raster data with buffering.</p> <p>Used for processing large rasters by dividing them into smaller windows with overlapping buffer regions. Ensures each window has sufficient context for operations that depend on neighboring pixels.</p> <p>Attributes:</p> <ul> <li><code>shape</code>: Raster dimensions <code>(height, width)</code>.</li> <li><code>window_size</code>: Core window size in pixels.</li> <li><code>buffer_size</code>: Buffer region size around each core window.</li> <li><code>total_window_size</code>: Total window size including buffers <code>(window_size + 2 * buffer_size)</code>.</li> <li><code>x_steps</code>, <code>y_steps</code>: Number of windows in each dimension.</li> </ul> <p>Example</p> <pre><code>import jax.numpy as jnp\nfrom jaxscape import WindowOperation\n\nraster = jnp.ones((100, 100))\nwindow_op = WindowOperation(\n    shape=raster.shape,\n    window_size=20,\n    buffer_size=10\n)\n</code></pre> <p>Warning</p> <p>You must ensure that <code>(shape[i] - 2 * buffer_size)</code> is divisible by <code>window_size</code> for both dimensions <code>i = 0, 1</code>. Consider using <code>jaxscape.utils.padding</code> to pad your raster data automatically.</p>"},{"location":"api/window_operations/#jaxscape.window_operation.WindowOperation.nb_steps","title":"<code>nb_steps</code>  <code>property</code>","text":"<p>Total number of windows in the raster.</p> <p>Example</p> <pre><code>window_op = WindowOperation(shape=(100, 100), window_size=20, buffer_size=10)\nprint(window_op.nb_steps)  # 25 (5x5 grid of windows)\n</code></pre>"},{"location":"api/window_operations/#jaxscape.window_operation.WindowOperation.extract_total_window","title":"<code>extract_total_window(xy: Array, raster: Array) -&gt; Array</code>","text":"<p>Extract a window including buffer regions from the raster.</p> <p>Arguments:</p> <ul> <li><code>xy</code>: Start coordinates <code>[x, y]</code> of the window.</li> <li><code>raster</code>: 2D raster array.</li> </ul> <p>Returns:</p> <p>Window of shape <code>(total_window_size, total_window_size)</code>.</p> <p>Example</p> <pre><code>window_op = WindowOperation(shape=(100, 100), window_size=20, buffer_size=10)\nraster = jnp.ones((100, 100))\nwindow = window_op.extract_total_window(jnp.array([0, 0]), raster)\n# window.shape = (40, 40)\n</code></pre>"},{"location":"api/window_operations/#jaxscape.window_operation.WindowOperation.extract_core_window","title":"<code>extract_core_window(xy: Array, raster: Array) -&gt; Array</code>","text":"<p>Extract the core window without buffers from the raster.</p> <p>Arguments:</p> <ul> <li><code>xy</code>: Start coordinates <code>[x, y]</code> of the total window.</li> <li><code>raster</code>: 2D raster array.</li> </ul> <p>Returns:</p> <p>Core window of shape <code>(window_size, window_size)</code>.</p> <p>Example</p> <pre><code>window_op = WindowOperation(shape=(100, 100), window_size=20, buffer_size=10)\nraster = jnp.ones((100, 100))\ncore = window_op.extract_core_window(jnp.array([0, 0]), raster)\n# core.shape = (20, 20)\n</code></pre>"},{"location":"api/window_operations/#jaxscape.window_operation.WindowOperation.update_raster_with_core_window","title":"<code>update_raster_with_core_window(xy: Array, raster: Array, raster_window: Array, fun: collections.abc.Callable[[jax.Array, jax.Array], jax.Array] = &lt;lambda&gt;) -&gt; Array</code>","text":"<p>Update raster by merging the core region of a processed window.</p> <p>Extracts the core (non-buffer) region from <code>raster_window</code> and updates the corresponding region in <code>raster</code> using the provided function.</p> <p>Arguments:</p> <ul> <li><code>xy</code>: Start coordinates <code>[x, y]</code> of the total window.</li> <li><code>raster</code>: Full raster array to update.</li> <li><code>raster_window</code>: Processed window including buffers.</li> <li><code>fun</code>: Function to combine current and new values. Defaults to replacement.</li> </ul> <p>Returns:</p> <p>Updated raster array.</p> <p>Example</p> <pre><code>window_op = WindowOperation(shape=(100, 100), window_size=20, buffer_size=10)\nraster = jnp.zeros((100, 100))\n\nfor xy, window in window_op.lazy_iterator(raster):\n    processed = compute_distance(window)\n    raster = window_op.update_raster_with_core_window(xy, raster, processed)\n</code></pre>"},{"location":"api/window_operations/#jaxscape.window_operation.WindowOperation.update_raster_with_window","title":"<code>update_raster_with_window(xy: Array, raster: Array, raster_window: Array, fun: collections.abc.Callable[[jax.Array, jax.Array], jax.Array] = &lt;lambda&gt;) -&gt; Array</code>","text":"<p>Update raster with the entire window including buffers.</p> <p>Arguments:</p> <ul> <li><code>xy</code>: Start coordinates <code>[x, y]</code> of the window.</li> <li><code>raster</code>: Full raster array to update.</li> <li><code>raster_window</code>: Processed window to merge.</li> <li><code>fun</code>: Function to combine current and new values. Defaults to replacement.</li> </ul> <p>Returns:</p> <p>Updated raster array.</p> <p>Example</p> <pre><code>window_op = WindowOperation(shape=(100, 100), window_size=20, buffer_size=10)\nraster = jnp.zeros((100, 100))\nwindow_data = jnp.ones((40, 40))\n\n# Replace window region\nraster = window_op.update_raster_with_window(\n    jnp.array([0, 0]), raster, window_data\n)\n\n# Accumulate with custom function\nraster = window_op.update_raster_with_window(\n    jnp.array([0, 0]), raster, window_data, fun=jnp.add\n)\n</code></pre>"},{"location":"api/window_operations/#jaxscape.window_operation.WindowOperation.lazy_iterator","title":"<code>lazy_iterator(raster: Array) -&gt; collections.abc.Generator[tuple[jax.Array, jax.Array], None, None]</code>","text":"<p>Iterate over windows one at a time.</p> <p>Memory-efficient iteration that yields windows sequentially without pre-computing all windows.</p> <p>Arguments:</p> <ul> <li><code>raster</code>: 2D raster array to iterate over.</li> </ul> <p>Yields:</p> <p>Tuples of <code>(xy, window)</code> where <code>xy</code> are start coordinates and <code>window</code> is the extracted window with buffers.</p> <p>Example</p> <pre><code>window_op = WindowOperation(shape=(100, 100), window_size=20, buffer_size=10)\nraster = jnp.ones((100, 100))\n\nfor xy, window in window_op.lazy_iterator(raster):\n    # Process each window sequentially\n    result = compute(window)\n    # window.shape = (40, 40)\n</code></pre>"},{"location":"api/window_operations/#jaxscape.window_operation.WindowOperation.eager_iterator","title":"<code>eager_iterator(matrix: Array) -&gt; tuple[jax.Array, jax.Array]</code>","text":"<p>Extract all windows at once for parallel processing.</p> <p>Pre-computes all windows in a single operation using <code>vmap</code>, enabling efficient batch processing and parallelization.</p> <p>Arguments:</p> <ul> <li><code>matrix</code>: 2D input raster array.</li> </ul> <p>Returns:</p> <p>Tuple <code>(xy, windows)</code> where <code>xy</code> has shape <code>(num_windows, 2)</code> containing start coordinates, and <code>windows</code> has shape <code>(num_windows, window_height, window_width)</code>.</p> <p>Example</p> <pre><code>window_op = WindowOperation(shape=(100, 100), window_size=20, buffer_size=10)\nraster = jnp.ones((100, 100))\n\nxy, windows = window_op.eager_iterator(raster)\n# xy.shape = (25, 2), windows.shape = (25, 40, 40)\n\n# Process all windows in parallel\nresults = jax.vmap(compute)(windows)\n</code></pre>"},{"location":"api/window_operations/#jaxscape.windowed_analysis.WindowedAnalysis","title":"<code>jaxscape.windowed_analysis.WindowedAnalysis</code>","text":"<p>Base class for windowed connectivity analyses on large rasters.</p> <p>Processes landscapes through hierarchical decomposition: batches (processed sequentially) contain windows (processed in parallel) with buffer zones for spatial dependencies.</p> <p>Parameters:</p> <ul> <li><code>quality_raster</code>: Habitat quality values.</li> <li><code>permeability_raster</code>: Movement permeability, or function <code>quality -&gt; permeability</code>.</li> <li><code>distance</code>: Distance metric (e.g., <code>LCPDistance()</code>, <code>ResistanceDistance()</code>).</li> <li><code>proximity</code>: Distance-to-proximity transform (e.g., <code>lambda d: jnp.exp(-d/D)</code>).</li> <li><code>coarsening_factor</code>: Spatial coarsening in [0, 1]. 0 = finest resolution, higher = faster.</li> <li><code>dependency_range</code>: Spatial dependency range in pixels (buffer size).</li> <li><code>batch_size</code>: Number of coarsened windows per batch (higher = more memory).</li> </ul> <p>Example</p> <pre><code>from jaxscape.connectivity_analysis import WindowedAnalysis\n\nclass CustomConnectivity(WindowedAnalysis):\n    def run(self, **kwargs):\n        result = 0.0\n        for xy_batch, quality_batch in self.batch_op.lazy_iterator(self.quality_raster):\n            result += process_batch(quality_batch)\n        return result\n</code></pre>"},{"location":"examples/advanced/moving_windows/","title":"Moving window operations","text":"<p>Process large rasters efficiently using spatial decomposition. JAXScape's <code>WindowOperation</code> divides landscapes into overlapping windows with buffer zones, enabling memory-efficient sequential processing or GPU-accelerated batch operations.</p>"},{"location":"examples/advanced/moving_windows/#prerequisites","title":"Prerequisites","text":"<pre><code>pip install jaxscape rasterio matplotlib\n</code></pre> <pre><code>import jax.numpy as jnp\nimport matplotlib.pyplot as plt\nimport rioxarray\nfrom jaxscape import padding, WindowOperation\n</code></pre> <p>Load habitat quality raster for demonstration.</p> <pre><code># Load habitat quality raster\nraster = rioxarray.open_rasterio(\"../data/suitability.tif\", masked=True)\nquality = jnp.array(\n    raster.sel(band=1).fillna(0), dtype=\"float32\"\n)  # Replace no-data values with 0\n\nprint(f\"Raster shape: {quality.shape}\")\nprint(f\"Value range: [{quality.min():.2f}, {quality.max():.2f}]\")\n</code></pre> <pre><code>Raster shape: (107, 182)\nValue range: [0.00, 100.00]\n</code></pre> <pre><code>/Users/victorboussange/projects/jaxscape/.venv/lib/python3.12/site-packages/pyproj/crs/_cf1x8.py:515: UserWarning: angle from rectified to skew grid parameter lost in conversion to CF\n  warnings.warn(\n</code></pre> <pre><code># Visualize the full raster\nfig, ax = plt.subplots(figsize=(10, 8))\nim = ax.imshow(quality, cmap=\"viridis\")\nax.set_title(\"Habitat quality raster\", fontsize=14, pad=20)\nax.axis(\"off\")\nplt.colorbar(im, ax=ax, label=\"Quality\", shrink=0.7)\nplt.tight_layout()\nplt.show()\n</code></pre> <p></p>"},{"location":"examples/advanced/moving_windows/#initialize-window-operation","title":"Initialize window operation","text":"<p>Window parameters define the tile size and overlap. Before feeding the raster to the <code>WindowOperation</code> class, we can use <code>jaxscape.padding</code> to ensure that windows have complete neighborhoods; <code>WindowOperation</code> will error otherwise.</p> <pre><code>buffer_size = 10  # Overlap zone to handle edge effects\nwindow_size = 50  # Core area of each window (in pixels)\n\nquality_padded = padding(quality, buffer_size, window_size)\n\nprint(f\"\\nOriginal raster shape: {quality.shape}\")\nprint(f\"Padded raster shape: {quality_padded.shape}\")\n\n# Initialize window operation manager\nwindow_op = WindowOperation(\n    shape=quality_padded.shape, window_size=window_size, buffer_size=buffer_size\n)\n\nprint(f\"Total number of windows: {window_op.nb_steps}\")\n</code></pre> <pre><code>Original raster shape: (107, 182)\nPadded raster shape: (120, 220)\nTotal number of windows: 8\n</code></pre>"},{"location":"examples/advanced/moving_windows/#lazy-iterator-memory-efficient-processing","title":"Lazy iterator: memory-efficient processing","text":"<p>The lazy iterator yields windows one at a time (via Python generator), ideal for memory-constrained environments or sequential processing. Each iteration provides window coordinates <code>(x, y)</code> and the data array. This enables processing arbitrarily large rasters as long as individual windows fit in memory.</p> <pre><code># Visualize all windows using lazy iteration\nn_windows = window_op.nb_steps\nn_cols = 4\nn_rows = int(jnp.ceil(n_windows / n_cols))\n\nfig, axs = plt.subplots(n_rows, n_cols, figsize=(12, 3 * n_rows))\naxs = axs.flatten() if n_windows &gt; 1 else [axs]\n\nfor i, (xy, window) in enumerate(window_op.lazy_iterator(quality_padded)):\n    ax = axs[i]\n    im = ax.imshow(window, cmap=\"viridis\")\n    ax.set_title(f\"Window {i+1}\\nPosition: ({xy[0]}, {xy[1]})\", fontsize=10)\n    ax.axis(\"off\")\n\n    # Draw rectangle showing core area (excluding buffer)\n    from matplotlib.patches import Rectangle\n\n    rect = Rectangle(\n        (buffer_size, buffer_size),\n        window_size,\n        window_size,\n        linewidth=2,\n        edgecolor=\"red\",\n        facecolor=\"none\",\n    )\n    ax.add_patch(rect)\n\n# Hide unused subplots\nfor j in range(i + 1, len(axs)):\n    axs[j].axis(\"off\")\n\nplt.tight_layout()\nplt.show()\n\nprint(f\"Processed {i+1} windows (red rectangles = core areas)\")\n</code></pre> <p></p> <pre><code>Processed 8 windows (red rectangles = core areas)\n</code></pre>"},{"location":"examples/advanced/moving_windows/#eager-iterator-vectorized-batch-processing","title":"Eager iterator: vectorized batch processing","text":"<p>The eager iterator loads all windows into memory at once, returning coordinate and data arrays with shapes <code>(n_windows, 2)</code> and <code>(n_windows, height, width)</code>. This enables vectorized operations across all windows simultaneously via <code>jax.vmap</code>, dramatically accelerating GPU/TPU processing. The trade-off is higher memory consumption.</p> <pre><code># Load all windows at once for batch processing\nxy_coords, windows = window_op.eager_iterator(quality_padded)\n\nprint(f\"Coordinates shape: {xy_coords.shape}\")\nprint(f\"Windows shape: {windows.shape}\")\n</code></pre> <pre><code>Coordinates shape: (8, 2)\nWindows shape: (8, 70, 70)\n</code></pre>"},{"location":"examples/advanced/moving_windows/#update-raster-with-processed-windows","title":"Update raster with processed windows","text":"<p>The <code>update_raster_with_focal_window</code> method replaces a window's core area (excluding buffers) with new data. It automatically handles buffer zones by writing only core regions, maintaining spatial continuity across window boundaries.</p> <pre><code># Example: Replace window 3's core area with ones (demonstrating update)\nwindow_index = 2  # Zero-indexed: window 3\nnew_window = jnp.ones(windows[window_index].shape, dtype=\"float32\")\n\n# Update the padded raster\nupdated_raster = window_op.update_raster_with_core_window(\n    xy_coords[window_index], quality_padded, new_window\n)\n\n# Visualize the updated raster\nfig, ax = plt.subplots(figsize=(10, 8))\nim = ax.imshow(updated_raster, cmap=\"viridis\")\nax.set_title(f\"Updated raster (window {window_index + 1} modified)\", fontsize=12)\nax.axis(\"off\")\nplt.tight_layout()\nplt.show()\n</code></pre> <p></p>"},{"location":"examples/connectivity_analysis/connectivity_analysis/","title":"Connectivity and sensitivity analysis at scale","text":"<p>This notebook demonstrates how to quantify ecological connectivity and perform sensitivity analysis over large landscapes, leveraging moving windows to accelerate computations using the <code>ConnectivityAnalysis</code> and <code>SensitivityAnalysis</code> utilities.</p>"},{"location":"examples/connectivity_analysis/connectivity_analysis/#prerequisites","title":"Prerequisites","text":"<pre><code>pip install jaxscape rasterio matplotlib\n</code></pre> <pre><code>import jax.numpy as jnp\nimport jax.random as jr\nimport matplotlib\nimport matplotlib.pyplot as plt\nimport rasterio\nfrom jaxscape import ConnectivityAnalysis, LCPDistance, SensitivityAnalysis\n</code></pre>"},{"location":"examples/connectivity_analysis/connectivity_analysis/#load-data","title":"Load data","text":"<p>We load a habitat \"suitability\" raster (typically the output of a species distribution model), and confound it with the permeability raster. We also use it to weight the importance of each site when calculating connectivity (see thereafter). In practice, you may want to use different rasters for these purposes.</p> <p>The raster values are normalized to [0, 1] range, with 0 representing unsuitable habitat and 1 representing optimal conditions.</p> <pre><code># Load habitat suitability raster\nwith rasterio.open(\"../data/suitability.tif\") as src:\n    raster = src.read(1, masked=True)  # Read first band with masking\n    quality_raster = (\n        jnp.array(raster.filled(0), dtype=\"float32\") / 100\n    )  # Normalize to [0, 1]\n\n# Visualize the landscape\nplt.figure(figsize=(10, 8))\nplt.imshow(quality_raster, cmap=\"viridis\")\nplt.colorbar(label=\"Habitat Quality/Permeability\", shrink=0.7)\nplt.title(\"Input Landscape\")\nplt.axis(\"off\")\nplt.show()\n</code></pre> <p></p>"},{"location":"examples/connectivity_analysis/connectivity_analysis/#define-dispersal-parameters-for-the-target-species","title":"Define dispersal parameters for the target species","text":"<p>We need to specify:</p> <ul> <li>Dispersal range (D): maximum distance an individual can traverse (in pixels) through optimal habitat (permeability = 1)</li> <li>Distance metric</li> <li>Proximity function: how distance translates to a certain probability of dispersal</li> </ul> <p>Common proximity functions are - Negative exponential: <code>exp(-d/D)</code> for smooth decay (used here) - Threshold: <code>(d &lt; D).astype(float)</code> for binary connectivity - Power law: <code>d**(-\u03b1)</code> for fat-tailed dispersal</p> <pre><code># Define dispersal range (in pixels; you'd need to convert from real units based on raster resolution)\nD = 20  # Maximum dispersal distance through optimal habitat\n\ndistance = LCPDistance()\n\n\n# Define proximity function: converts distance to probability of dispersal\ndef proximity(dist):\n    \"\"\"Negative exponential decay of connectivity with distance.\"\"\"\n    return jnp.exp(-dist / D)\n</code></pre>"},{"location":"examples/connectivity_analysis/connectivity_analysis/#calculate-landscape-connectivity","title":"Calculate landscape connectivity","text":"<p><code>ConnectivityAnalysis</code> computes the overall landscape connectivity by summing quality-weighted proximities between all pairs of habitat cells. This produces a scalar measure of total connectivity.</p> <p>Key parameters: - <code>quality_raster</code>: Habitat quality or patch importance - <code>permeability_raster</code>: Movement cost surface - <code>distance</code>: Distance metric (LCP, Resistance, or RSP) - <code>proximity</code>: Function converting distance to connectivity - <code>dependency_range</code>: Maximum relevant distance (optimization parameter) - <code>batch_size</code>: Parallel processing batch size (tune based on available memory) - <code>q_weighted</code>: Whether to weight by quality (<code>True</code>) or not (<code>False</code>)</p> <pre><code># Initialize connectivity analysis\nconnectivity_prob = ConnectivityAnalysis(\n    quality_raster=quality_raster,\n    permeability_raster=quality_raster,\n    distance=distance,\n    proximity=proximity,\n    dependency_range=D,\n    batch_size=50,  # Process 50 cells per batch\n)\n\n# Compute baseline connectivity (unweighted by quality)\nconnectivity = connectivity_prob.run(q_weighted=False)\nprint(f\"Baseline landscape connectivity: {connectivity:.0f}\")\n</code></pre> <pre><code>Batch progress:   0%|          | 0/6 [00:00&lt;?, ?it/s]\n</code></pre> <pre><code>Batch progress: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 6/6 [00:09&lt;00:00,  1.60s/it]\n</code></pre> <pre><code>Baseline landscape connectivity: 3843798\n</code></pre> <pre><code>\n</code></pre> <p>Coarsening factor</p> <p>You can specify a <code>coarsening_factor</code> to aggregate the raster spatially, reducing resolution to speed up computations. A value of 0.0 means no aggregation, while higher values increase aggregation. This is an experimental feature and may affect accuracy.</p>"},{"location":"examples/connectivity_analysis/connectivity_analysis/#sensitivity-analysis","title":"Sensitivity analysis","text":"<p><code>SensitivityAnalysis</code> computes the derivative of <code>ConnectivityAnalysis</code> with respect to either permeability or quality. This allows identifying which landscape cells, when improved, would most increase overall connectivity.</p> <p>The output is a raster where each cell value represents the marginal effect of improving that cell on total connectivity.</p> <pre><code># Initialize sensitivity analysis\nsensitivity_prob = SensitivityAnalysis(\n    quality_raster=quality_raster,\n    permeability_raster=quality_raster,\n    distance=distance,\n    proximity=proximity,\n    dependency_range=D,\n    batch_size=20,  # Smaller batch size for memory efficiency\n)\n\n# Compute sensitivity with respect to permeability\nsensitivity_permeability = sensitivity_prob.run(\"permeability\", q_weighted=True)\n</code></pre> <pre><code>Batch progress: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 32/32 [00:29&lt;00:00,  1.08it/s]\n</code></pre> <p>It is usually advised to convert sensitivity to elasticity, which express the proportional change in connectivity from a proportional change in permeability. This is computed as:</p> \\[\\text{Elasticity} = \\frac{\\partial C}{\\partial p} \\times p\\] <p>where \\(C\\) is the ecological connectivity and \\(p\\) is permeability.</p> <p>Elasticity is more interpretable than raw sensitivity because it's scale-independent and represents percent change in connectivity per percent change in permeability.</p> <p>High elasticity areas are the most impactful for conservation - small improvements there yield large connectivity gains.</p> <pre><code># Compute elasticity: sensitivity \u00d7 current permeability\nelasticity = sensitivity_permeability * quality_raster\nelasticity = jnp.nan_to_num(elasticity, nan=0.0)  # Replace NaN with 0\n\n# Visualize elasticity on log scale (highlights variation)\nplt.figure(figsize=(10, 8))\nplt.imshow(\n    elasticity + 1e-2,  # Add small constant for log scale\n    cmap=\"plasma\",\n    norm=matplotlib.colors.LogNorm(vmin=1e0),\n)\nplt.axis(\"off\")\ncbar = plt.colorbar(shrink=0.6)\ncbar.set_label(\"Elasticity w.r.t permeability\", fontsize=12)\nplt.tight_layout()\nplt.show()\n</code></pre> <p></p>"},{"location":"examples/connectivity_analysis/connectivity_analysis/#conservation-prioritization-comparing-strategies","title":"Conservation prioritization: comparing strategies","text":"<p>We now compare two prioritization strategies for habitat restoration, to demonstrate the practical value of sensitivity analysis:</p> <ol> <li>Elasticity-based: Target the top 5% of cells by elasticity</li> <li>Random: Target random cells (control)</li> </ol> <p>For each strategy, we simulate improving permeability by 0.4 units (40% of the scale) and measure the resulting gain in landscape connectivity.</p> <pre><code># Define improvement magnitude\nimproved_permeability = 0.4  # Permeability increase per restored cell\n\n# Strategy 1: Target high elasticity cells (top 5%)\nthreshold = jnp.percentile(elasticity, 95)  # 95th percentile\nhigh_sensitivity_coords = jnp.where(elasticity &gt;= threshold)\nimproved_quality_raster = quality_raster.at[high_sensitivity_coords].add(\n    improved_permeability\n)\n\nprint(\n    f\"Strategy 1: Restoring {high_sensitivity_coords[0].size} cells based on elasticity\"\n)\n\n# Strategy 2: Target random cells (same number as Strategy 1)\nkey = jr.PRNGKey(0)\nrandom_indices = jr.choice(\n    key,\n    jnp.arange(elasticity.size),\n    shape=(high_sensitivity_coords[0].size,),\n    replace=False,\n)\nrandom_coords = jnp.unravel_index(random_indices, quality_raster.shape)\nmodified_quality_raster = quality_raster.at[random_coords].add(improved_permeability)\n\nprint(f\"Strategy 2: Restoring {random_coords[0].size} random cells (control)\")\n</code></pre> <pre><code>Strategy 1: Restoring 974 cells based on elasticity\nStrategy 2: Restoring 974 random cells (control)\n</code></pre> <p>We now compute landscape connectivity for: 1. Baseline (no restoration) 2. Elasticity-based restoration 3. Random restoration</p> <p>The connectivity gain is expressed as a percentage increase over baseline.</p> <pre><code>def run_connectivity_analysis(raster):\n    \"\"\"Helper function to compute connectivity for a given permeability raster.\"\"\"\n    connectivity_prob = ConnectivityAnalysis(\n        quality_raster=quality_raster,\n        permeability_raster=raster,\n        distance=distance,\n        proximity=proximity,\n        coarsening_factor=0.0,\n        dependency_range=D,\n        batch_size=50,\n    )\n    return connectivity_prob.run(q_weighted=True)\n\n\n# Compute connectivity for all scenarios\nprint(\"Computing connectivity for baseline...\")\nbase_connectivity = run_connectivity_analysis(quality_raster)\n\nprint(\"Computing connectivity for elasticity-based restoration...\")\nconnectivity_improved = run_connectivity_analysis(improved_quality_raster)\n\nprint(\"Computing connectivity for random restoration...\")\nconnectivity_improved_randomly = run_connectivity_analysis(modified_quality_raster)\n\n# Calculate percent gains\nelasticity_gain = (connectivity_improved - base_connectivity) / base_connectivity * 100\nrandom_gain = (\n    (connectivity_improved_randomly - base_connectivity) / base_connectivity * 100\n)\n\n# Visualize comparison\nfig, ax = plt.subplots(figsize=(5, 5))\nstrategies = [\"Baseline\", \"Elasticity-based\", \"Random\"]\nconnectivities = [\n    base_connectivity,\n    connectivity_improved,\n    connectivity_improved_randomly,\n]\ncolors = [\"gray\", \"green\", \"orange\"]\n\nbars = ax.bar(strategies, connectivities, color=colors, alpha=0.7, edgecolor=\"black\")\nax.set_ylabel(\"Landscape Connectivity\", fontsize=12)\nax.set_title(\"Restoration Strategy Comparison\", fontsize=14, pad=20)\nax.grid(axis=\"y\", alpha=0.3)\n\n# Add percentage labels\nfor i, (bar, val) in enumerate(zip(bars, connectivities)):\n    if i &gt; 0:\n        gain = (val - base_connectivity) / base_connectivity * 100\n        ax.text(\n            bar.get_x() + bar.get_width() / 2,\n            bar.get_height(),\n            f\"+{gain:.1f}%\",\n            ha=\"center\",\n            va=\"bottom\",\n            fontsize=11,\n            fontweight=\"bold\",\n        )\n\nplt.tight_layout()\nplt.show()\n</code></pre> <pre><code>Computing connectivity for baseline...\n</code></pre> <pre><code>Batch progress: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 6/6 [00:09&lt;00:00,  1.60s/it]\n</code></pre> <pre><code>Computing connectivity for elasticity-based restoration...\n</code></pre> <pre><code>Batch progress: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 6/6 [00:09&lt;00:00,  1.60s/it]\n</code></pre> <pre><code>Computing connectivity for random restoration...\n</code></pre> <pre><code>Batch progress: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 6/6 [00:09&lt;00:00,  1.60s/it]\n</code></pre> <p></p> <p>The results demonstrate the advantage of using elasticity-based prioritization over random selection. By targeting high-elasticity areas, we achieve greater connectivity gains with the same restoration budget.</p>"},{"location":"examples/connectivity_analysis/connectivity_analysis/#key-takeaways","title":"Key Takeaways","text":"<p>This notebook demonstrated how sensitivity analysis identifies landscape modifications with the greatest connectivity impact. By converting raw sensitivity to elasticity (a scale-independent measure), we can prioritize restoration sites objectively. The results show that elasticity-based targeting substantially outperforms random selection, achieving greater connectivity gains with the same restoration budget.</p> <p>JAXScape's automatic differentiation through JAX enables efficient computation of these gradient-based metrics at landscape scale. The framework is highly flexible: you can substitute different distance metrics (LCP, Resistance, RSP), proximity functions (exponential, threshold, power law), dispersal parameters, or conservation objectives (quality enhancement versus permeability improvement) to match your species and management scenarios. You may also implement your own definition of ecological connectivity; see the API reference.</p>"},{"location":"examples/distance_calculation/distance_calculation/","title":"Distance calculation","text":"<p>JAXScape makes landscape connectivity analysis fast and differentiable. Here we demonstrate how to compute different distance metrics on a graph and use automatic differentiation to identify which landscape pixels, if improved, would most increase connectivity\u2014essential for connectivity conservation prioritization.</p>"},{"location":"examples/distance_calculation/distance_calculation/#prerequisites","title":"Prerequisites","text":"<pre><code>pip install jaxscape numpy matplotlib equinox\n</code></pre> <pre><code>import equinox as eqx\nimport jax\nimport jax.numpy as jnp\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom jaxscape import GridGraph, LCPDistance, ResistanceDistance, RSPDistance\n</code></pre>"},{"location":"examples/distance_calculation/distance_calculation/#loading-data","title":"Loading data","text":"<p>The landscape is represented as a permeability raster (the inverse of resistance), where each pixel value indicates how easily organisms move through that location. Higher permeability values represent easier movement, while lower values represent barriers. In this example, the raster contains binary values (0s and 1s).</p> <p>Info</p> <p>JAXScape uses permeability rather than resistance because permeability has better numerical properties\u2014infinite resistance (complete barrier) naturally maps to zero permeability, avoiding numerical issues.</p> <pre><code># Load permeability raster\npermeability = (\n    jnp.array(np.loadtxt(\"../data/permeability.csv\", delimiter=\",\")) + 0.001\n)  # Add small constant to allow for movement (for numerical stability)\n\n# Visualize the permeability landscape\nfig, ax = plt.subplots(figsize=(3, 3))\nim = ax.imshow(permeability, cmap=\"gray\")\nax.set_xticks([])\nax.set_yticks([])\nfor spine in ax.spines.values():\n    spine.set_visible(True)\nplt.colorbar(im, ax=ax, label=\"Permeability\", shrink=0.7)\nplt.tight_layout()\nplt.show()\n</code></pre> <p></p>"},{"location":"examples/distance_calculation/distance_calculation/#create-graph","title":"Create graph","text":"<p>JAXScape converts the raster to a grid graph where pixels are nodes and edges connect neighbors with weights derived from the raster of permeability values.</p> <pre><code># Construct grid graph from permeability raster\ngrid = GridGraph(grid=permeability, fun=lambda x, y: (x + y) / 2)\n</code></pre> <p>The <code>fun</code> parameter defines how to compute edge weights from neighboring pixel values. Here, we use the average of the two pixels, so that our graph is undirected.</p>"},{"location":"examples/distance_calculation/distance_calculation/#define-source-pixel","title":"Define source pixel","text":"<p>A nodes in a <code>GridGraph</code> can be referenced by its (row, column) coordinates, or by its flattened index. Here, we compute distances from the top-left pixel to all other locations.</p> <pre><code># Define source location (top-left corner)\nsource = grid.coord_to_index(jnp.array([0]), jnp.array([0]))\n\nprint(f\"Source coordinates: (0, 0)\")\nprint(f\"Source node index: {source[0]}\")\n\n# Convert back to verify\nsource_coords = grid.index_to_coord(source)\nprint(f\"Verification - coordinates: ({source_coords[0, 0]}, {source_coords[0, 1]})\")\n</code></pre> <pre><code>Source coordinates: (0, 0)\nSource node index: 0\nVerification - coordinates: (0, 0)\n</code></pre>"},{"location":"examples/distance_calculation/distance_calculation/#compute-distance-metrics","title":"Compute distance metrics","text":"<p>JAXScape currently offers three distance metrics:</p> <p><code>LCPDistance</code> finds the single optimal route (deterministic movement). <code>RSPDistance</code> considers multiple paths weighted by cost, with temperature parameter \u03b8 controlling stochasticity. <code>ResistanceDistance</code> treats the landscape as an electrical network, naturally accounting for all paths (suitable for gene flow).</p> <pre><code>from jaxscape.solvers import CholmodSolver\n\n\n# Initialize distance metrics\ndistances = {\n    \"LCP Distance\": LCPDistance(),\n    \"RSP Distance\": RSPDistance(\n        theta=0.01,  # Low temperature \u2192 more deterministic\n        cost=lambda x: 1 / x,  # Cost inversely proportional to permeability\n    ),\n    \"Resistance Distance\": ResistanceDistance(solver=CholmodSolver()),\n}\n</code></pre> <p>Solver Configuration</p> <p><code>ResistanceDistance</code> requires a linear solver, which significantly impacts both memory usage and computational speed. JAXScape provides two optimized solver options:</p> <ul> <li>PyAMG (<code>PyAMGSolver</code>): Algebraic multigrid solver with moderate memory footprint</li> <li>Cholesky (<code>CholmodSolver</code>): Faster but requires more memory</li> </ul> <p>Installation (Python 3.10-3.12 only): <pre><code>uv add jaxscape --extra pyamg      # Install PyAMG solver\nuv add jaxscape --extra cholespy   # Install Cholesky solver\nuv add jaxscape --extra solvers    # Install both solvers\n</code></pre></p> <p>Optional solvers support</p> <p>These optional solvers are not tested in CI/CD. The <code>cholespy</code> package does not provide wheels for Python 3.13+.</p> <p>Default behavior: If no solver is specified, JAXScape falls back to matrix inversion, which is very inefficient for large graphs (&gt;5k nodes). Always specify a solver for production use.</p> <pre><code>distance_arrays = {}\nfor name, distance_metric in distances.items():\n    print(f\"Computing {name}...\")\n\n    # Compute distances\n    dist_to_node = distance_metric(grid, source)\n\n    # Convert from node values to 2D array and mask low-permeability areas\n    dist_array = grid.node_values_to_array(dist_to_node.ravel())\n    dist_array = dist_array * (permeability &gt; 0.1)  # Mask barriers\n\n    distance_arrays[name] = dist_array\n</code></pre> <pre><code>Computing LCP Distance...\nComputing RSP Distance...\nComputing Resistance Distance...\n</code></pre> <pre><code># Visualize all three distance metrics\nfig, axs = plt.subplots(1, 3, figsize=(10, 4))\n\nfor ax, (title, dist_array) in zip(axs, distance_arrays.items()):\n    im = ax.imshow(dist_array, cmap=\"magma\")\n    ax.set_title(title, fontsize=12, pad=15)\n    ax.axis(\"off\")\n\n    # Mark source location\n    circle = plt.Circle(\n        (0, 0), radius=0.5, fill=False, edgecolor=\"#f72585\", linewidth=2\n    )\n    ax.add_patch(circle)\n\n    plt.colorbar(im, ax=ax, shrink=0.6, label=\"\")\n\nfig.suptitle(\"Distance from Source (Top-Left Corner)\", fontsize=14, y=1.02)\nplt.tight_layout()\nplt.show()\n</code></pre> <p></p> <pre><code>fig.savefig(\"distances.png\", dpi=300, transparent=True, bbox_inches=\"tight\")\n</code></pre>"},{"location":"examples/distance_calculation/distance_calculation/#sensitivity-analysis-with-automatic-differentiation","title":"Sensitivity analysis with automatic differentiation","text":"<p>JAXScape distance metrics are fully differentiable. This enables computing gradients of connectivity metrics with respect to the permeability matrix, revealing how changes in each pixel affect overall connectivity.</p> <p>We'll calculate the gradient of average path length (APL)\u2014the mean distance between all node pairs\u2014with respect to permeability. The resulting gradient <code>\u2202APL/\u2202permeability</code> identifies connectivity bottlenecks across the landscape.</p> <p>Interpreting sensitivity</p> <p>Pixels with large negative gradients are high-priority restoration targets: improving permeability at these locations yields the greatest reduction in average path length, thus maximizing connectivity gain.</p> <pre><code>@eqx.filter_jit\ndef average_path_length(permeability, distance_metric):\n    \"\"\"Compute average path length across all node pairs.\n\n    This is a global connectivity measure: lower values indicate\n    better overall connectivity.\n    \"\"\"\n    grid = GridGraph(permeability)\n    dist = distance_metric(grid)\n    return dist.sum() / grid.nv**2\n\n\n# Create gradient function\ngrad_connectivity = jax.grad(average_path_length)\n# Compute sensitivity (gradient)\nsensitivities = grad_connectivity(permeability, LCPDistance())\n\n# Mask barriers for visualization\nsensitivities_masked = sensitivities * (permeability &gt; 0.1)\n\nfig, ax = plt.subplots(figsize=(4, 4))\n# Sensitivity map\nim = ax.imshow(sensitivities_masked, cmap=\"magma\")\nax.set_title(\"Sensitivity: \u2202APL/\u2202Permeability\", fontsize=12, pad=15)\nax.axis(\"off\")\n\nplt.colorbar(im, ax=ax, shrink=0.7, label=\"Sensitivity\")\nplt.tight_layout()\n</code></pre> <p></p> <p>You've learned JAXScape's core workflow: constructing grid graphs from rasters, computing distance metrics (LCP, RSP, Resistance), and using automatic differentiation for sensitivity analysis. The gradient-based approach identifies connectivity bottlenecks for data-driven conservation prioritization.</p>"},{"location":"examples/inverse_landscape_genetics/inverse_landscape_genetics/","title":"Inverse landscape genetics","text":"<p>Traditional landscape genetics assumes a priori which habitat features facilitate or impede movement. Inverse landscape genetics reverses this approach, inferring permeability patterns directly from genetic data. This notebook demonstrates fitting a neural network to predict landscape resistance from land-cover features, optimizing the model to match observed genetic differentiation (Fst) between sampling sites.</p> <p>We use genetic data from the Mountain Pygmy-possum (Burramys parvus), an endangered marsupial endemic to alpine regions of southeastern Australia, kindly provided by Cesar Australia. We'll use land-cover data to model landscape permeability and fit the model to observed genetic distances, obtained from ESA WorldCover.</p>"},{"location":"examples/inverse_landscape_genetics/inverse_landscape_genetics/#prerequisites","title":"Prerequisites","text":"<pre><code>pip install jaxscape equinox optimistix rioxarray geopandas scikit-learn\n</code></pre> <p>We've prepared the data for you to focus on the modeling aspects; you can download the dataset here. </p> <pre><code>import time\n\nimport equinox as eqx\nimport geopandas as gpd\nimport jax\nimport jax.numpy as jnp\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport optimistix as optx\nimport rioxarray\nimport xarray as xr\nfrom equinox import nn\nfrom jaxscape import GridGraph, ResistanceDistance\nfrom jaxscape.solvers import CholmodSolver\nfrom sklearn.metrics import mean_squared_error, r2_score\nfrom sklearn.model_selection import train_test_split\n\n\n# Set random seed for reproducibility\nnp.random.seed(42)\n</code></pre>"},{"location":"examples/inverse_landscape_genetics/inverse_landscape_genetics/#configuration-parameters","title":"Configuration parameters","text":"<pre><code># File paths (adjust to your data location)\nLANDCOVER_PATH = \"../data/cesar/landcover_7855.tif\"\nSITE_METADATA_PATH = \"../data/cesar/site_metadata.gpkg\"\nGENETIC_DISTANCES_PATH = \"../data/cesar/genetic_dissimilarity.npy\"\n\n# Model configuration\nCOARSENING_FACTOR = (\n    10  # Spatial downsampling of feature raster to accelerate computation\n)\nSOLVER = CholmodSolver()  # Fast linear solver for large graphs\nDISTANCE_FUN = ResistanceDistance(solver=SOLVER)  # Effective resistance distance\nMAX_STEPS = 500  # Maximum optimization iterations\n\n# Alternative distance metric for experimentation:\n# DISTANCE_FUN = LCPDistance()  # Least-cost path distance\n</code></pre>"},{"location":"examples/inverse_landscape_genetics/inverse_landscape_genetics/#load-the-data","title":"Load the data","text":"<pre><code># Load land-cover raster\npredictor_raster = rioxarray.open_rasterio(\n    LANDCOVER_PATH,\n    mask_and_scale=True,\n)\n\n# Load site metadata (geographic locations)\nsite_metadata = gpd.read_file(SITE_METADATA_PATH)\nsite_gdf = site_metadata.to_crs(epsg=7855)  # Reproject to Australian GDA2020\n\n# Load genetic distance matrix\ngenetic_distances = np.load(GENETIC_DISTANCES_PATH)\n\nprint(f\"Predictor raster shape: {predictor_raster.shape}\")\nprint(f\"Number of sites: {len(site_gdf)}\")\nprint(f\"Genetic distance matrix shape: {genetic_distances.shape}\")\n</code></pre> <pre><code>Predictor raster shape: (1, 4596, 3052)\nNumber of sites: 12\nGenetic distance matrix shape: (12, 12)\n</code></pre>"},{"location":"examples/inverse_landscape_genetics/inverse_landscape_genetics/#prepare-features-and-targets","title":"Prepare features and targets","text":"<p>The land-cover raster requires preprocessing before feeding it to the neural network. We first compress the sparse WorldCover class IDs into a contiguous range (0..K-1), then one-hot encode them into binary feature vectors. Spatial coarsening via mean pooling downsamples the raster while preserving land-cover composition within each aggregated cell, capturing habitat heterogeneity without forcing discrete classifications. Finally, we map each sampling site to its nearest grid cell in the coarsened raster. </p> <pre><code>def prepare_feature_targets(predictor_raster, site_gdf, coarsening_factor):\n    \"\"\"Process land-cover and create model inputs.\n\n    Returns\n    -------\n    features_onehot_coarse : array\n        One-hot encoded land-cover features after coarsening (H, W, K)\n    unique_classes : array\n        Original WorldCover class values\n    target_nodes : array\n        Node indices for sampling sites\n    grid : GridGraph\n        Reference grid for node indexing\n    feature_da : xarray.DataArray\n        Coarsened feature raster with coordinates\n    \"\"\"\n    # Compress WorldCover classes to contiguous IDs\n    raw_band = np.asarray(predictor_raster.sel(band=1))\n    unique_vals, inverse = np.unique(raw_band.ravel(), return_inverse=True)\n    class_ids = inverse.reshape(raw_band.shape).astype(np.int32)\n    features_categorical = jnp.array(class_ids).squeeze()\n    unique_classes = jnp.array(unique_vals)\n\n    print(f\"Found {len(unique_vals)} unique land-cover classes\")\n\n    # One-hot encode: (H, W) -&gt; (H, W, K)\n    features_onehot = jax.nn.one_hot(features_categorical, num_classes=len(unique_vals))\n\n    # Reorder for coarsening: (H, W, K) -&gt; (K, H, W)\n    features_onehot = jnp.moveaxis(features_onehot, -1, 0)\n\n    # Coarsen using mean pooling (preserves class composition)\n    coords = {\n        \"band\": np.arange(features_onehot.shape[0]),\n        \"y\": predictor_raster.y.values,\n        \"x\": predictor_raster.x.values,\n    }\n    feature_da = xr.DataArray(\n        features_onehot,\n        coords=coords,\n        dims=(\"band\", \"y\", \"x\"),\n    )\n    feature_da = feature_da.coarsen(\n        x=coarsening_factor, y=coarsening_factor, boundary=\"trim\"\n    ).mean()\n\n    # Back to (H, W, K)\n    features_onehot_coarse = jnp.moveaxis(feature_da.data, 0, -1)\n    print(f\"Coarsened feature shape: {features_onehot_coarse.shape}\")\n\n    # Map site coordinates to coarsened grid indices\n    x_idx = jnp.array(\n        [\n            int(np.argmin(np.abs(feature_da.x.values - x)))\n            for x in site_gdf.geometry.x.values\n        ]\n    )\n    y_idx = jnp.array(\n        [\n            int(np.argmin(np.abs(feature_da.y.values - y)))\n            for y in site_gdf.geometry.y.values\n        ]\n    )\n\n    # Create reference grid for node indexing\n    grid = GridGraph(\n        jnp.ones((feature_da.x.size, feature_da.y.size)), fun=lambda x, y: (x + y) / 2\n    )\n    target_nodes = grid.coord_to_index(x_idx, y_idx)\n\n    return features_onehot_coarse, unique_classes, target_nodes, grid, feature_da\n\n\n# Process features\n(\n    features_onehot,\n    unique_classes,\n    target_nodes,\n    ref_grid,\n    coarse_feature_da,\n) = prepare_feature_targets(predictor_raster, site_gdf, COARSENING_FACTOR)\n\nprint(f\"Target nodes (site indices): {target_nodes}\")\n</code></pre> <pre><code>Found 8 unique land-cover classes\nCoarsened feature shape: (459, 305, 8)\nTarget nodes (site indices): [112719  65962  29307  27474  35742 109760  36622  37079  76894  63615\n  35723  91477]\n</code></pre> <pre><code>from matplotlib.patches import Circle\n\n\n# Visualize coarsened land-cover with sites\nnode_coords = ref_grid.index_to_coord(target_nodes)\nx_indices, y_indices = node_coords[:, 0], node_coords[:, 1]\n\nfig, ax = plt.subplots(figsize=(12, 10))\nim = ax.imshow(features_onehot.argmax(axis=-1), cmap=\"Accent\")\n\n# Add colorbar for land-cover types\nplt.colorbar(im, ax=ax, label=\"Land-cover type\", shrink=0.6)\n\n# Annotate sites\nfor xi, yi, name in zip(x_indices, y_indices, site_gdf[\"site_name\"].values):\n    circle = Circle(\n        (int(xi), int(yi)),\n        radius=3,\n        fill=False,\n        edgecolor=\"#f72585\",\n        linewidth=2,\n    )\n    ax.add_patch(circle)\n\n    ax.text(\n        int(xi),\n        int(yi) - 5,\n        str(name),\n        color=\"black\",\n        fontsize=10,\n        fontweight=\"bold\",\n        ha=\"center\",\n        va=\"bottom\",\n        bbox=dict(facecolor=\"white\", alpha=0.9, edgecolor=\"black\", pad=2),\n    )\n\nax.set_title(\"Land-cover types with sampling sites\", fontsize=14, pad=20)\nax.axis(\"off\")\nplt.tight_layout()\nplt.show()\n</code></pre> <p></p>"},{"location":"examples/inverse_landscape_genetics/inverse_landscape_genetics/#define-the-permeability-model","title":"Define the permeability model","text":"<p>We build a neural network mapping one-hot land-cover features to positive permeability values: \\(\\text{permeability} = \\exp(\\text{NN}(\\text{features})) + \\epsilon\\). The architecture takes a K-dimensional one-hot vector (land-cover classes), passes it through two hidden layers with ReLU activation (16 units each), and outputs a single value that is exponentiated to ensure positivity. We apply this model pixel-wise via <code>vmap</code> to generate the full permeability surface.</p> <pre><code>def build_model(num_classes: int, seed: int = 2) -&gt; tuple:\n    \"\"\"Build neural permeability model.\n\n    Parameters\n    ----------\n    num_classes : int\n        Number of land-cover classes\n    seed : int\n        Random seed for initialization\n\n    Returns\n    -------\n    model : eqx.Module\n        Complete model\n    params : pytree\n        Trainable parameters\n    static : pytree\n        Static (non-trainable) components\n    \"\"\"\n    key = jax.random.PRNGKey(seed)\n\n    class PermeabilityModel(eqx.Module):\n        layers: list\n        num_classes: int\n\n        def __init__(self, num_classes: int, key):\n            self.num_classes = num_classes\n            k1, k2, k3 = jax.random.split(key, 3)\n            hidden_dim = 16\n\n            self.layers = [\n                nn.Linear(num_classes, hidden_dim, key=k1),\n                jax.nn.relu,\n                nn.Linear(hidden_dim, hidden_dim, key=k2),\n                jax.nn.relu,\n                nn.Linear(hidden_dim, 1, key=k3),\n            ]\n\n        def __call__(self, x):\n            \"\"\"Map one-hot feature to positive permeability.\"\"\"\n            for layer in self.layers:\n                x = layer(x)\n            return jnp.minimum(\n                jnp.exp(x) + 1e-1, 1e3\n            )  # Ensure positive permeability, keep within reasonable bounds\n\n    model = PermeabilityModel(num_classes, key)\n    params, static = eqx.partition(model, eqx.is_inexact_array)\n    return model, params, static\n\n\n# Initialize model\nmodel, params, static = build_model(len(unique_classes))\nprint(f\"Model initialized with {len(unique_classes)} land-cover classes\")\nprint(f\"Trainable parameters: {sum(p.size for p in jax.tree_util.tree_leaves(params))}\")\n</code></pre> <pre><code>Model initialized with 8 land-cover classes\nTrainable parameters: 433\n</code></pre> <p>Before training, the model produces random permeability values based on the initialization.</p> <pre><code># Apply model to all pixels via vmap\nmodel_vmapped = jax.vmap(jax.vmap(model, in_axes=0), in_axes=0)\ninitial_permeability = model_vmapped(features_onehot).squeeze()\n\nfig, ax = plt.subplots(figsize=(12, 10))\nim = ax.imshow(initial_permeability, cmap=\"RdYlGn\")\nax.set_title(\"Initial permeability prediction\", fontsize=14, pad=20)\nax.axis(\"off\")\nplt.colorbar(im, ax=ax, label=\"Permeability\", shrink=0.6)\nplt.tight_layout()\nplt.show()\n</code></pre> <p></p>"},{"location":"examples/inverse_landscape_genetics/inverse_landscape_genetics/#define-loss-function-and-training-setup","title":"Define loss function and training setup","text":"<p>We minimize mean squared error (MSE) between predicted resistance distances and observed genetic distances. The training loop predicts pixel-wise permeability, constructs a GridGraph, computes pairwise resistance distances between sampling sites, and backpropagates gradients through the entire pipeline using L-BFGS optimization.</p> <p>We split pairwise distances (upper triangle of the matrix) into 80% training and 20% test sets to evaluate generalization. This train/test split reveals whether the model learns meaningful permeability patterns or simply memorizes training data.</p> <pre><code>@eqx.filter_jit\ndef loss_fn(params, args):\n    static, features, target_flat_train, tri_i_train, tri_j_train = args\n\n    # Reconstruct model and predict permeability surface\n    model = eqx.combine(params, static)\n    model_vmapped = jax.vmap(jax.vmap(model, in_axes=0), in_axes=0)\n    permeability = model_vmapped(features).squeeze()\n\n    # Build graph and compute permeability distances\n    grid = GridGraph(permeability, fun=lambda x, y: (x + y) / 2)\n    predicted_distances = DISTANCE_FUN(grid, nodes=target_nodes)\n\n    # Extract training pairs and compute loss\n    pred_flat_train = predicted_distances[tri_i_train, tri_j_train]\n    return ((target_flat_train - pred_flat_train) ** 2).mean()\n</code></pre> <pre><code># Extract upper triangle indices (all unique pairs)\nn_sites = genetic_distances.shape[0]\ntri_i_all, tri_j_all = np.triu_indices(n_sites, k=1)\ntarget_flat_all = np.asarray(genetic_distances)[tri_i_all, tri_j_all]\n\nprint(f\"Total pairwise distances: {len(target_flat_all)}\")\n\n# Train/test split (80/20)\n(\n    target_flat_train,\n    target_flat_test,\n    tri_i_train,\n    tri_i_test,\n    tri_j_train,\n    tri_j_test,\n) = train_test_split(\n    target_flat_all,\n    tri_i_all,\n    tri_j_all,\n    test_size=0.2,\n    random_state=2,\n)\n\n# Convert to JAX arrays for training\ntri_i_train = jnp.array(tri_i_train)\ntri_j_train = jnp.array(tri_j_train)\ntri_i_test = np.array(tri_i_test)\ntri_j_test = np.array(tri_j_test)\n\nprint(f\"Training pairs: {len(target_flat_train)}\")\nprint(f\"Test pairs: {len(target_flat_test)}\")\n\n# Sanity check: compute initial loss\ninitial_loss = loss_fn(\n    params, (static, features_onehot, target_flat_train, tri_i_train, tri_j_train)\n)\nprint(f\"\\nInitial training loss: {initial_loss:.6f}\")\n</code></pre> <pre><code>Total pairwise distances: 66\nTraining pairs: 52\nTest pairs: 14\n\nInitial training loss: 3.885685\n</code></pre>"},{"location":"examples/inverse_landscape_genetics/inverse_landscape_genetics/#training","title":"Training","text":"<p>The optimization typically takes several minutes depending on graph size and the number of iterations required for convergence.</p> <pre><code># Configure L-BFGS optimizer\nsolver = optx.LBFGS(\n    rtol=1e-5,  # Relative tolerance for convergence\n    atol=1e-5,  # Absolute tolerance\n    verbose=frozenset({\"loss\"}),  # Print loss during optimization\n)\n\nprint(\"Starting optimization...\\n\")\nprint(\"=\" * 60)\n\nstart_train_time = time.time()\n\n# Run optimization\nopt_solution = optx.minimise(\n    loss_fn,\n    solver,\n    params,\n    args=(static, features_onehot, target_flat_train, tri_i_train, tri_j_train),\n    max_steps=MAX_STEPS,\n)\n\ntraining_time = time.time() - start_train_time\n\nprint(\"=\" * 60)\nprint(f\"\\n\u2713 Training completed in {training_time:.2f} seconds\")\nprint(f\"\\nOptimization statistics:\")\nprint(opt_solution.stats)\n</code></pre> <pre><code>Starting optimization...\n\n============================================================\nLoss on this step: 3.8856894969940186, Loss on the last accepted step: 0.0\nLoss on this step: 0.009540650993585587, Loss on the last accepted step: 3.8856894969940186\nLoss on this step: 0.009540597908198833, Loss on the last accepted step: 3.8856894969940186\nLoss on this step: 0.0021442112047225237, Loss on the last accepted step: 3.8856894969940186\nLoss on this step: 0.0021369722671806812, Loss on the last accepted step: 0.0021442112047225237\nLoss on this step: 0.0019680014811456203, Loss on the last accepted step: 0.0021369722671806812\nLoss on this step: 0.0019522022921591997, Loss on the last accepted step: 0.0019680014811456203\nLoss on this step: 0.0019508968107402325, Loss on the last accepted step: 0.0019522022921591997\nLoss on this step: 0.0019490730483084917, Loss on the last accepted step: 0.0019508968107402325\nLoss on this step: 0.001943937037140131, Loss on the last accepted step: 0.0019490730483084917\nLoss on this step: 0.0019331614021211863, Loss on the last accepted step: 0.001943937037140131\nLoss on this step: 0.0019099907949566841, Loss on the last accepted step: 0.0019331614021211863\nLoss on this step: 0.0018720333464443684, Loss on the last accepted step: 0.0019099907949566841\nLoss on this step: 0.0017763919895514846, Loss on the last accepted step: 0.0018720333464443684\nLoss on this step: 0.0016488881083205342, Loss on the last accepted step: 0.0017763919895514846\nLoss on this step: 0.0016327609773725271, Loss on the last accepted step: 0.0016488881083205342\nLoss on this step: 0.0016295629320666194, Loss on the last accepted step: 0.0016327609773725271\nLoss on this step: 0.0016266308957710862, Loss on the last accepted step: 0.0016295629320666194\nLoss on this step: 0.0016214561183005571, Loss on the last accepted step: 0.0016266308957710862\nLoss on this step: 0.0016075350577011704, Loss on the last accepted step: 0.0016214561183005571\nLoss on this step: 0.0015825879527255893, Loss on the last accepted step: 0.0016075350577011704\nLoss on this step: 0.001501547172665596, Loss on the last accepted step: 0.0015825879527255893\nLoss on this step: 0.06288988888263702, Loss on the last accepted step: 0.001501547172665596\nLoss on this step: 0.002140212105587125, Loss on the last accepted step: 0.001501547172665596\nLoss on this step: 0.0016243921127170324, Loss on the last accepted step: 0.001501547172665596\nLoss on this step: 0.0014579362468793988, Loss on the last accepted step: 0.001501547172665596\nLoss on this step: 0.001322284690104425, Loss on the last accepted step: 0.0014579362468793988\nLoss on this step: 0.0014171540969982743, Loss on the last accepted step: 0.001322284690104425\nLoss on this step: 0.0013643365819007158, Loss on the last accepted step: 0.001322284690104425\nLoss on this step: 0.0013415651628747582, Loss on the last accepted step: 0.001322284690104425\nLoss on this step: 0.0013335972325876355, Loss on the last accepted step: 0.001322284690104425\nLoss on this step: 0.001321864314377308, Loss on the last accepted step: 0.001322284690104425\nLoss on this step: 0.0013171337777748704, Loss on the last accepted step: 0.001322284690104425\nLoss on this step: 0.001312931883148849, Loss on the last accepted step: 0.0013171337777748704\nLoss on this step: 0.0013678910909220576, Loss on the last accepted step: 0.001312931883148849\nLoss on this step: 0.0012855114182457328, Loss on the last accepted step: 0.001312931883148849\nLoss on this step: 0.0021188759710639715, Loss on the last accepted step: 0.0012855114182457328\nLoss on this step: 0.0012452633818611503, Loss on the last accepted step: 0.0012855114182457328\nLoss on this step: 0.0012341703986749053, Loss on the last accepted step: 0.0012452633818611503\nLoss on this step: 0.00123458297457546, Loss on the last accepted step: 0.0012341703986749053\nLoss on this step: 0.0012321530375629663, Loss on the last accepted step: 0.0012341703986749053\nLoss on this step: 0.0012285209959372878, Loss on the last accepted step: 0.0012321530375629663\nLoss on this step: 0.00122746080160141, Loss on the last accepted step: 0.0012285209959372878\nLoss on this step: 0.0012268684804439545, Loss on the last accepted step: 0.00122746080160141\nLoss on this step: 0.0012262093368917704, Loss on the last accepted step: 0.0012268684804439545\nLoss on this step: 0.0012240996584296227, Loss on the last accepted step: 0.0012262093368917704\nLoss on this step: 0.0012296241475269198, Loss on the last accepted step: 0.0012240996584296227\nLoss on this step: 0.0012167698005214334, Loss on the last accepted step: 0.0012240996584296227\nLoss on this step: 0.001307217637076974, Loss on the last accepted step: 0.0012167698005214334\nLoss on this step: 0.0012273594038560987, Loss on the last accepted step: 0.0012167698005214334\nLoss on this step: 0.0012153689749538898, Loss on the last accepted step: 0.0012167698005214334\nLoss on this step: 0.0012151197297498584, Loss on the last accepted step: 0.0012153689749538898\nLoss on this step: 0.0012136436998844147, Loss on the last accepted step: 0.0012153689749538898\nLoss on this step: 0.001213698647916317, Loss on the last accepted step: 0.0012136436998844147\nLoss on this step: 0.0012138065649196506, Loss on the last accepted step: 0.0012136436998844147\nLoss on this step: 0.0012139827013015747, Loss on the last accepted step: 0.0012136436998844147\nLoss on this step: 0.0012137620942667127, Loss on the last accepted step: 0.0012136436998844147\nLoss on this step: 0.001213753828778863, Loss on the last accepted step: 0.0012136436998844147\nLoss on this step: 0.0012136644218116999, Loss on the last accepted step: 0.0012136436998844147\nLoss on this step: 0.0012136156437918544, Loss on the last accepted step: 0.0012136436998844147\nLoss on this step: 0.0012142040068283677, Loss on the last accepted step: 0.0012136156437918544\nLoss on this step: 0.001213707379065454, Loss on the last accepted step: 0.0012136156437918544\nLoss on this step: 0.0012137291487306356, Loss on the last accepted step: 0.0012136156437918544\nLoss on this step: 0.001213960931636393, Loss on the last accepted step: 0.0012136156437918544\nLoss on this step: 0.0012137801386415958, Loss on the last accepted step: 0.0012136156437918544\nLoss on this step: 0.0012137687299400568, Loss on the last accepted step: 0.0012136156437918544\nLoss on this step: 0.00121373834554106, Loss on the last accepted step: 0.0012136156437918544\nLoss on this step: 0.001213651499710977, Loss on the last accepted step: 0.0012136156437918544\nLoss on this step: 0.0012136161094531417, Loss on the last accepted step: 0.0012136156437918544\nLoss on this step: 0.001213617972098291, Loss on the last accepted step: 0.0012136156437918544\nLoss on this step: 0.0012136263540014625, Loss on the last accepted step: 0.0012136156437918544\nLoss on this step: 0.001213613897562027, Loss on the last accepted step: 0.0012136156437918544\n============================================================\n\n\u2713 Training completed in 154.03 seconds\n\nOptimization statistics:\n{'max_steps': 500, 'num_steps': Array(72, dtype=int32, weak_type=True)}\n</code></pre>"},{"location":"examples/inverse_landscape_genetics/inverse_landscape_genetics/#visualize-the-learned-permeability-surface","title":"Visualize the learned permeability surface","text":"<pre><code># Apply fitted model to landscape\nfitted_model = eqx.combine(opt_solution.value, static)\nfitted_vmapped = jax.vmap(jax.vmap(fitted_model, in_axes=0), in_axes=0)\nfitted_permeability = fitted_vmapped(features_onehot).squeeze()\n</code></pre> <pre><code># Compute predicted distances using fitted permeability\npred_grid = GridGraph(fitted_permeability, fun=lambda x, y: (x + y) / 2)\npred_distances = DISTANCE_FUN(pred_grid, nodes=target_nodes)\n\ngenetic_np = np.asarray(genetic_distances)\npred_np = np.asarray(pred_distances)\n\n# Extract predictions for train and test pairs\ntrain_pred = pred_np[tri_i_train, tri_j_train]\ntest_pred = pred_np[tri_i_test, tri_j_test]\ntrain_target = target_flat_train\ntest_target = target_flat_test\n\n# Compute metrics\nr2_train = r2_score(train_target, train_pred)\nr2_test = r2_score(test_target, test_pred)\nrmse_train = np.sqrt(mean_squared_error(train_target, train_pred))\nrmse_test = np.sqrt(mean_squared_error(test_target, test_pred))\n\nfig, ax = plt.subplots(figsize=(6, 6))\n\n# Plot training and test predictions\nax.scatter(\n    train_pred,\n    train_target,\n    s=60,\n    alpha=0.6,\n    edgecolor=\"none\",\n    label=\"Training\",\n    c=\"#2E86AB\",\n)\nax.scatter(\n    test_pred,\n    test_target,\n    s=80,\n    alpha=0.8,\n    edgecolor=\"black\",\n    linewidth=1,\n    label=\"Test\",\n    c=\"#A23B72\",\n)\n\n# 1:1 reference line\nmin_val = min(pred_np.min(), genetic_np.min())\nmax_val = max(pred_np.max(), genetic_np.max())\nax.plot(\n    [min_val, max_val],\n    [min_val, max_val],\n    \"k--\",\n    linewidth=2,\n    alpha=0.5,\n    label=\"1:1 line\",\n)\n\nax.set_xlabel(\"Predicted resistance distance\", fontsize=12)\nax.set_ylabel(\"Observed genetic distance (Fst)\", fontsize=12)\n\n# Add metrics box\ntextstr = (\n    f\"Training\\n\"\n    f\"  R\u00b2 = {r2_train:.3f}\\n\"\n    f\"  RMSE = {rmse_train:.4f}\\n\\n\"\n    f\"Test\\n\"\n    f\"  R\u00b2 = {r2_test:.3f}\\n\"\n    f\"  RMSE = {rmse_test:.4f}\"\n)\nax.text(\n    0.05,\n    0.95,\n    textstr,\n    transform=ax.transAxes,\n    fontsize=10,\n    verticalalignment=\"top\",\n    bbox=dict(\n        boxstyle=\"round\", facecolor=\"white\", alpha=0.9, edgecolor=\"gray\", linewidth=1.5\n    ),\n)\n\nax.legend(loc=\"lower right\", fontsize=11, framealpha=0.9)\nax.grid(True, alpha=0.3, linestyle=\":\")\nplt.tight_layout()\nplt.show()\n</code></pre> <p>Our model seems to perform reasonably well, capturing a significant portion of the variance in genetic distances.  We can now visualize the learned permeability patterns across the landscape. Remember that this is to be interpreted with great caution, as the inferred permeability surface may reflect complex interactions and correlations in the data rather than direct causal relationships.</p> <pre><code>fig, ax = plt.subplots(figsize=(12, 10))\n\n# Fitted permeability\nim = ax.imshow(fitted_permeability, cmap=\"RdYlGn_r\")\nax.set_title(\"Predicted permeability surface\\nafter training\", fontsize=13, pad=15)\nax.axis(\"off\")\nplt.colorbar(im, ax=ax, shrink=0.6, label=\"Permeability\")\n\nplt.tight_layout()\nplt.show()\n</code></pre> <p></p> <p>The red surface corresponds to mountain ranges, separating the different populations. To go further, we could use more informative features, such as elevation, climate, etc...</p>"},{"location":"examples/inverse_landscape_genetics/inverse_landscape_genetics/#key-takeaways","title":"Key takeaways","text":"<p>This notebook demonstrated inverse landscape genetics: learning resistance patterns from genetic data rather than assuming them a priori. JAX's automatic differentiation enables gradient-based optimization, allowing to train neural networks to map landscape features to a permeability surface. Neural networks provide flexible parameterization capturing nonlinear landscape feature\u2013permeability relationships. It would be interesting to compare this learned resistance surface with expert knowledge about the species' ecology and known barriers to movement in the landscape. We could also assess the predictive performance of e.g. the <code>LCPDistance</code>. But this goes beyond the scope of this notebook.</p>"}]}